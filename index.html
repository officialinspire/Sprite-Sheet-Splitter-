<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprite Sheet Splitter | #teamInspire</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #fff;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 0 0 20px rgba(102, 126, 234, 0.8);
        }

        .subtitle {
            text-align: center;
            margin-bottom: 30px;
            color: #b8c6db;
            font-size: 0.9em;
        }

        .upload-section {
            background: rgba(255, 255, 255, 0.05);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-section:hover {
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.1);
        }

        .upload-section.dragover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.2);
        }

        #fileInput {
            display: none;
        }

        .upload-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 25px;
            font-size: 1.1em;
            cursor: pointer;
            transition: transform 0.2s ease;
            font-family: 'Courier New', monospace;
        }

        .upload-btn:hover {
            transform: scale(1.05);
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #b8c6db;
        }

        .control-group input,
        .control-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-family: 'Courier New', monospace;
        }

        .control-group input[type="checkbox"] {
            width: auto;
            margin-right: 10px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .preview-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
        }

        #canvasContainer {
            background: 
                repeating-conic-gradient(#808080 0% 25%, #404040 0% 50%) 
                50% / 20px 20px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            overflow: auto;
            max-height: 600px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        #previewCanvas {
            display: block;
            image-rendering: pixelated;
            cursor: crosshair;
            position: relative;
        }

        .grid-line {
            position: absolute;
            background: rgba(102, 126, 234, 0.7);
            z-index: 10;
            transition: background 0.2s ease;
        }

        .grid-line.vertical {
            width: 8px;
            height: 100%;
            cursor: ew-resize;
            margin-left: -4px;
        }

        .grid-line.horizontal {
            height: 8px;
            width: 100%;
            cursor: ns-resize;
            margin-top: -4px;
        }

        .grid-line:hover {
            background: rgba(102, 126, 234, 1);
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.8);
        }

        .grid-line.dragging {
            background: rgba(118, 75, 162, 1);
            z-index: 20;
            box-shadow: 0 0 20px rgba(118, 75, 162, 1);
        }

        .grid-handle {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #667eea;
            border: 3px solid white;
            border-radius: 50%;
            cursor: grab;
            z-index: 15;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        }

        .grid-handle:hover {
            background: #764ba2;
            transform: translate(-50%, -50%) scale(1.4);
            box-shadow: 0 4px 15px rgba(118, 75, 162, 0.6);
        }

        .grid-handle.dragging {
            cursor: grabbing;
            background: #764ba2;
            transform: translate(-50%, -50%) scale(1.5);
            box-shadow: 0 6px 20px rgba(118, 75, 162, 0.8);
        }

        .canvas-wrapper {
            position: relative;
            display: inline-block;
        }

        .mode-toggle {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
        }

        .mode-btn {
            padding: 10px 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Courier New', monospace;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #667eea;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
        }

        .mode-btn:hover {
            border-color: rgba(255, 255, 255, 0.6);
        }

        .sprites-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .sprite-card {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .sprite-card:hover {
            border-color: #667eea;
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }

        .sprite-preview {
            background: 
                repeating-conic-gradient(#808080 0% 25%, #404040 0% 50%) 
                50% / 10px 10px;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            min-height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .sprite-preview canvas {
            image-rendering: pixelated;
            max-width: 100%;
            max-height: 100%;
        }

        .sprite-name {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-family: 'Courier New', monospace;
            text-align: center;
        }

        .sprite-actions {
            display: flex;
            gap: 5px;
        }

        .sprite-btn {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            transition: all 0.2s ease;
        }

        .save-png {
            background: #10b981;
            color: white;
        }

        .save-jpg {
            background: #f59e0b;
            color: white;
        }

        .save-png:hover {
            background: #059669;
        }

        .save-jpg:hover {
            background: #d97706;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .action-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1em;
            cursor: pointer;
            transition: transform 0.2s ease;
            font-family: 'Courier New', monospace;
        }

        .action-btn:hover {
            transform: scale(1.05);
        }

        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .info-box {
            background: rgba(102, 126, 234, 0.2);
            border-left: 4px solid #667eea;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            color: #b8c6db;
            margin-top: 5px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            h1 {
                font-size: 1.8em;
            }

            .controls {
                grid-template-columns: 1fr;
            }

            .sprites-grid {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚úÇÔ∏è SPRITE SHEET SPLITTER</h1>
        <div class="subtitle">#teamInspire Web Tools</div>

        <div class="info-box">
            <strong>üìã Instructions:</strong> Upload your sprite sheet, set the grid dimensions (columns √ó rows), 
            optionally enable transparent background removal, then split and save individual sprites!
        </div>

        <div class="upload-section" id="uploadSection">
            <p style="margin-bottom: 20px; font-size: 1.2em;">üìÅ Drop sprite sheet here or click to browse</p>
            <input type="file" id="fileInput" accept="image/*">
            <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                Select Sprite Sheet
            </button>
        </div>

        <div class="controls" id="controls" style="display: none;">
            <div class="control-group">
                <label>Columns (sprites wide)</label>
                <input type="number" id="columns" value="3" min="1" max="50">
            </div>

            <div class="control-group">
                <label>Rows (sprites tall)</label>
                <input type="number" id="rows" value="2" min="1" max="50">
            </div>

            <div class="control-group">
                <label>Left Margin (px)</label>
                <input type="number" id="leftMargin" value="0" min="0">
            </div>

            <div class="control-group">
                <label>Top Margin (px)</label>
                <input type="number" id="topMargin" value="0" min="0">
            </div>

            <div class="control-group">
                <label>Right Margin (px)</label>
                <input type="number" id="rightMargin" value="0" min="0">
            </div>

            <div class="control-group">
                <label>Bottom Margin (px)</label>
                <input type="number" id="bottomMargin" value="0" min="0">
            </div>

            <div class="control-group">
                <label>Horizontal Spacing (px)</label>
                <input type="number" id="hSpacing" value="0" min="0">
            </div>

            <div class="control-group">
                <label>Vertical Spacing (px)</label>
                <input type="number" id="vSpacing" value="0" min="0">
            </div>

            <div class="control-group">
                <label>Sprite Width Override (px)</label>
                <input type="number" id="spriteWidth" placeholder="Auto-calculate">
            </div>

            <div class="control-group">
                <label>Sprite Height Override (px)</label>
                <input type="number" id="spriteHeight" placeholder="Auto-calculate">
            </div>

            <div class="control-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="transparentBg">
                    Remove Background (make transparent)
                </label>
            </div>

            <div class="control-group" id="toleranceGroup" style="display: none;">
                <label>Color Tolerance (0-255)</label>
                <input type="number" id="tolerance" value="30" min="0" max="255">
            </div>
        </div>

        <div class="preview-section" id="previewSection" style="display: none;">
            <h2 style="margin-bottom: 15px;">üìê Preview with Grid Overlay</h2>
            
            <div class="mode-toggle">
                <button class="mode-btn active" id="gridModeBtn" onclick="setMode('grid')">
                    üìê Grid Mode
                </button>
                <button class="mode-btn" id="manualModeBtn" onclick="setMode('manual')">
                    ‚úã Manual Mode (Drag Lines)
                </button>
            </div>

            <div id="manualControls" style="display: none; margin-bottom: 15px; text-align: center;">
                <div style="background: rgba(255, 255, 255, 0.05); padding: 15px; border-radius: 10px; display: inline-block;">
                    <strong>Fine Adjustments:</strong>
                    <div style="margin-top: 10px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; justify-content: center;">
                        <button class="action-btn" onclick="addVerticalLine()" style="padding: 8px 15px;">
                            ‚ûï Add Column
                        </button>
                        <button class="action-btn" onclick="addHorizontalLine()" style="padding: 8px 15px;">
                            ‚ûï Add Row
                        </button>
                        <button class="action-btn" onclick="removeLastVerticalLine()" style="padding: 8px 15px;">
                            ‚ûñ Remove Column
                        </button>
                        <button class="action-btn" onclick="removeLastHorizontalLine()" style="padding: 8px 15px;">
                            ‚ûñ Remove Row
                        </button>
                        <button class="action-btn" onclick="distributeVerticalLines()" style="padding: 8px 15px;">
                            üìè Even Columns
                        </button>
                        <button class="action-btn" onclick="distributeHorizontalLines()" style="padding: 8px 15px;">
                            üìè Even Rows
                        </button>
                    </div>
                </div>
            </div>

            <div style="margin-bottom: 15px; text-align: center;">
                <div style="background: rgba(255, 255, 255, 0.05); padding: 10px; border-radius: 10px; display: inline-block;">
                    <strong>Zoom:</strong>
                    <button class="action-btn" onclick="changeZoom(-0.2)" style="padding: 8px 15px; margin: 0 5px;">‚ûñ</button>
                    <span id="zoomLevel" style="margin: 0 10px;">100%</span>
                    <button class="action-btn" onclick="changeZoom(0.2)" style="padding: 8px 15px; margin: 0 5px;">‚ûï</button>
                    <button class="action-btn" onclick="resetZoom()" style="padding: 8px 15px; margin-left: 10px;">üîÑ Reset</button>
                </div>
            </div>

            <div id="canvasContainer">
                <div class="canvas-wrapper" id="canvasWrapper">
                    <canvas id="previewCanvas"></canvas>
                </div>
            </div>

            <div class="action-buttons">
                <button class="action-btn" id="splitBtn" onclick="splitSprites()">
                    ‚úÇÔ∏è Split into Sprites
                </button>
                <button class="action-btn" onclick="resetApp()">
                    üîÑ Start Over
                </button>
            </div>
        </div>

        <div id="spritesSection" style="display: none;">
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-value" id="spriteCount">0</div>
                    <div class="stat-label">Sprites Extracted</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="spriteSize">0√ó0</div>
                    <div class="stat-label">Sprite Dimensions</div>
                </div>
            </div>

            <div style="margin: 20px 0; text-align: center;">
                <button class="action-btn" onclick="saveAllSprites('png')">
                    üíæ Save All as PNG
                </button>
                <button class="action-btn" onclick="saveAllSprites('jpg')">
                    üíæ Save All as JPG
                </button>
            </div>

            <div class="sprites-grid" id="spritesGrid"></div>
        </div>
    </div>

    <script>
        let spriteSheetImage = null;
        let sprites = [];
        let editMode = 'grid'; // 'grid' or 'manual'
        let verticalLines = [];
        let horizontalLines = [];
        let draggingLine = null;
        let dragStartPos = { x: 0, y: 0 };
        let zoomLevel = 1.0;

        // File upload handling
        const uploadSection = document.getElementById('uploadSection');
        const fileInput = document.getElementById('fileInput');

        uploadSection.addEventListener('click', () => {
            fileInput.click();
        });

        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        });

        uploadSection.addEventListener('dragleave', () => {
            uploadSection.classList.remove('dragover');
        });

        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                loadImage(file);
            }
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                loadImage(file);
            }
        });

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    spriteSheetImage = img;
                    displayPreview();
                    document.getElementById('controls').style.display = 'grid';
                    document.getElementById('previewSection').style.display = 'block';
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // Control changes
        const controlIds = ['columns', 'rows', 'spriteWidth', 'spriteHeight', 
                           'leftMargin', 'topMargin', 'rightMargin', 'bottomMargin',
                           'hSpacing', 'vSpacing'];
        
        controlIds.forEach(id => {
            document.getElementById(id).addEventListener('input', () => {
                if (editMode === 'grid') updatePreview();
            });
        });
        
        document.getElementById('transparentBg').addEventListener('change', (e) => {
            document.getElementById('toleranceGroup').style.display = e.target.checked ? 'block' : 'none';
        });

        function setMode(mode) {
            editMode = mode;
            
            document.getElementById('gridModeBtn').classList.toggle('active', mode === 'grid');
            document.getElementById('manualModeBtn').classList.toggle('active', mode === 'manual');
            document.getElementById('manualControls').style.display = mode === 'manual' ? 'block' : 'none';
            
            if (mode === 'grid') {
                updatePreview();
            } else {
                drawManualGrid();
            }
        }

        function displayPreview() {
            updatePreview();
        }

        function updatePreview() {
            if (!spriteSheetImage) return;

            const canvas = document.getElementById('previewCanvas');
            const ctx = canvas.getContext('2d');

            canvas.width = spriteSheetImage.width;
            canvas.height = spriteSheetImage.height;

            ctx.drawImage(spriteSheetImage, 0, 0);

            // Get all parameters
            const cols = parseInt(document.getElementById('columns').value) || 1;
            const rows = parseInt(document.getElementById('rows').value) || 1;
            
            const leftMargin = parseInt(document.getElementById('leftMargin').value) || 0;
            const topMargin = parseInt(document.getElementById('topMargin').value) || 0;
            const rightMargin = parseInt(document.getElementById('rightMargin').value) || 0;
            const bottomMargin = parseInt(document.getElementById('bottomMargin').value) || 0;
            
            const hSpacing = parseInt(document.getElementById('hSpacing').value) || 0;
            const vSpacing = parseInt(document.getElementById('vSpacing').value) || 0;

            const customWidth = parseInt(document.getElementById('spriteWidth').value);
            const customHeight = parseInt(document.getElementById('spriteHeight').value);

            // Calculate available space
            const availableWidth = canvas.width - leftMargin - rightMargin - (hSpacing * (cols - 1));
            const availableHeight = canvas.height - topMargin - bottomMargin - (vSpacing * (rows - 1));

            const spriteWidth = customWidth || (availableWidth / cols);
            const spriteHeight = customHeight || (availableHeight / rows);

            // Generate line positions
            verticalLines = [];
            horizontalLines = [];

            // Add left boundary
            verticalLines.push(leftMargin);
            
            // Add column lines
            for (let i = 1; i <= cols; i++) {
                const x = leftMargin + (i * spriteWidth) + ((i - 1) * hSpacing);
                verticalLines.push(x);
            }

            // Add top boundary
            horizontalLines.push(topMargin);
            
            // Add row lines
            for (let i = 1; i <= rows; i++) {
                const y = topMargin + (i * spriteHeight) + ((i - 1) * vSpacing);
                horizontalLines.push(y);
            }

            if (editMode === 'grid') {
                drawGridLines(ctx);
            } else {
                drawManualGrid();
            }
        }

        function drawGridLines(ctx) {
            ctx.strokeStyle = 'rgba(102, 126, 234, 0.8)';
            ctx.lineWidth = 2;

            // Draw vertical lines
            verticalLines.forEach(x => {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, spriteSheetImage.height);
                ctx.stroke();
            });

            // Draw horizontal lines
            horizontalLines.forEach(y => {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(spriteSheetImage.width, y);
                ctx.stroke();
            });
        }

        function drawManualGrid() {
            if (!spriteSheetImage) return;

            const canvas = document.getElementById('previewCanvas');
            const ctx = canvas.getContext('2d');
            const wrapper = document.getElementById('canvasWrapper');

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(spriteSheetImage, 0, 0);

            // Remove old line elements
            const oldLines = wrapper.querySelectorAll('.grid-line, .grid-handle');
            oldLines.forEach(el => el.remove());

            // Create draggable vertical lines
            verticalLines.forEach((x, index) => {
                const line = document.createElement('div');
                line.className = 'grid-line vertical';
                line.style.left = (x * zoomLevel) + 'px';
                line.style.height = (canvas.height * zoomLevel) + 'px';
                line.dataset.index = index;
                line.dataset.type = 'vertical';
                
                // Add handle
                const handle = document.createElement('div');
                handle.className = 'grid-handle';
                handle.style.left = (x * zoomLevel) + 'px';
                handle.style.top = ((canvas.height * zoomLevel) / 2) + 'px';
                handle.dataset.index = index;
                handle.dataset.type = 'vertical';
                
                // Don't allow dragging boundaries unless there are extra lines
                if (index !== 0 && index !== verticalLines.length - 1) {
                    setupDragging(line);
                    setupDragging(handle);
                } else {
                    line.style.opacity = '0.5';
                    handle.style.display = 'none';
                }
                
                wrapper.appendChild(line);
                wrapper.appendChild(handle);
            });

            // Create draggable horizontal lines
            horizontalLines.forEach((y, index) => {
                const line = document.createElement('div');
                line.className = 'grid-line horizontal';
                line.style.top = (y * zoomLevel) + 'px';
                line.style.width = (canvas.width * zoomLevel) + 'px';
                line.dataset.index = index;
                line.dataset.type = 'horizontal';
                
                // Add handle
                const handle = document.createElement('div');
                handle.className = 'grid-handle';
                handle.style.left = ((canvas.width * zoomLevel) / 2) + 'px';
                handle.style.top = (y * zoomLevel) + 'px';
                handle.dataset.index = index;
                handle.dataset.type = 'horizontal';
                
                // Don't allow dragging boundaries unless there are extra lines
                if (index !== 0 && index !== horizontalLines.length - 1) {
                    setupDragging(line);
                    setupDragging(handle);
                } else {
                    line.style.opacity = '0.5';
                    handle.style.display = 'none';
                }
                
                wrapper.appendChild(line);
                wrapper.appendChild(handle);
            });
        }

        function setupDragging(element) {
            element.addEventListener('mousedown', startDrag);
            element.addEventListener('touchstart', startDrag, { passive: false });
        }

        function startDrag(e) {
            if (editMode !== 'manual') return;
            
            e.preventDefault();
            e.stopPropagation();
            
            const element = e.currentTarget;
            const type = element.dataset.type;
            const index = parseInt(element.dataset.index);
            
            // Don't allow dragging boundaries
            if (type === 'vertical' && (index === 0 || index === verticalLines.length - 1)) return;
            if (type === 'horizontal' && (index === 0 || index === horizontalLines.length - 1)) return;
            
            element.classList.add('dragging');
            
            const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
            const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
            
            draggingLine = { element, type, index };
            dragStartPos = { 
                x: clientX, 
                y: clientY,
                linePos: type === 'vertical' ? verticalLines[index] : horizontalLines[index]
            };
            
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('touchend', stopDrag);
        }

        function drag(e) {
            if (!draggingLine) return;
            e.preventDefault();
            
            const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
            const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
            
            const deltaX = (clientX - dragStartPos.x) / zoomLevel;
            const deltaY = (clientY - dragStartPos.y) / zoomLevel;
            
            if (draggingLine.type === 'vertical') {
                let newX = dragStartPos.linePos + deltaX;
                
                // Constrain between adjacent lines with larger buffer
                const minX = verticalLines[draggingLine.index - 1] + 5;
                const maxX = verticalLines[draggingLine.index + 1] - 5;
                newX = Math.max(minX, Math.min(maxX, newX));
                
                verticalLines[draggingLine.index] = newX;
                
                // Update visual position
                const wrapper = document.getElementById('canvasWrapper');
                const lines = wrapper.querySelectorAll(`[data-type="vertical"][data-index="${draggingLine.index}"]`);
                lines.forEach(line => {
                    line.style.left = (newX * zoomLevel) + 'px';
                });
            } else {
                let newY = dragStartPos.linePos + deltaY;
                
                // Constrain between adjacent lines with larger buffer
                const minY = horizontalLines[draggingLine.index - 1] + 5;
                const maxY = horizontalLines[draggingLine.index + 1] - 5;
                newY = Math.max(minY, Math.min(maxY, newY));
                
                horizontalLines[draggingLine.index] = newY;
                
                // Update visual position
                const wrapper = document.getElementById('canvasWrapper');
                const lines = wrapper.querySelectorAll(`[data-type="horizontal"][data-index="${draggingLine.index}"]`);
                lines.forEach(line => {
                    line.style.top = (newY * zoomLevel) + 'px';
                });
            }
        }

        function stopDrag() {
            if (draggingLine) {
                draggingLine.element.classList.remove('dragging');
                draggingLine = null;
            }
            
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', stopDrag);
            document.removeEventListener('touchmove', drag);
            document.removeEventListener('touchend', stopDrag);
        }

        // Manual adjustment functions
        function addVerticalLine() {
            if (verticalLines.length < 2) return;
            // Add line at midpoint of last two lines
            const lastTwo = verticalLines.slice(-2);
            const newX = (lastTwo[0] + lastTwo[1]) / 2;
            verticalLines.splice(-1, 0, newX);
            drawManualGrid();
        }

        function addHorizontalLine() {
            if (horizontalLines.length < 2) return;
            const lastTwo = horizontalLines.slice(-2);
            const newY = (lastTwo[0] + lastTwo[1]) / 2;
            horizontalLines.splice(-1, 0, newY);
            drawManualGrid();
        }

        function removeLastVerticalLine() {
            if (verticalLines.length <= 2) return;
            verticalLines.splice(-2, 1);
            drawManualGrid();
        }

        function removeLastHorizontalLine() {
            if (horizontalLines.length <= 2) return;
            horizontalLines.splice(-2, 1);
            drawManualGrid();
        }

        function distributeVerticalLines() {
            if (verticalLines.length < 3) return;
            const start = verticalLines[0];
            const end = verticalLines[verticalLines.length - 1];
            const count = verticalLines.length;
            const spacing = (end - start) / (count - 1);
            
            for (let i = 0; i < count; i++) {
                verticalLines[i] = start + (i * spacing);
            }
            drawManualGrid();
        }

        function distributeHorizontalLines() {
            if (horizontalLines.length < 3) return;
            const start = horizontalLines[0];
            const end = horizontalLines[horizontalLines.length - 1];
            const count = horizontalLines.length;
            const spacing = (end - start) / (count - 1);
            
            for (let i = 0; i < count; i++) {
                horizontalLines[i] = start + (i * spacing);
            }
            drawManualGrid();
        }

        // Zoom functions
        function changeZoom(delta) {
            zoomLevel = Math.max(0.2, Math.min(3.0, zoomLevel + delta));
            updateZoomDisplay();
            applyZoom();
        }

        function resetZoom() {
            zoomLevel = 1.0;
            updateZoomDisplay();
            applyZoom();
        }

        function updateZoomDisplay() {
            document.getElementById('zoomLevel').textContent = Math.round(zoomLevel * 100) + '%';
        }

        function applyZoom() {
            const canvas = document.getElementById('previewCanvas');
            canvas.style.transform = `scale(${zoomLevel})`;
            canvas.style.transformOrigin = 'top left';
            
            if (editMode === 'manual') {
                drawManualGrid();
            }
        }

        function splitSprites() {
            if (!spriteSheetImage) return;

            sprites = [];

            const removeBackground = document.getElementById('transparentBg').checked;
            const tolerance = parseInt(document.getElementById('tolerance').value) || 30;

            // Create temporary canvas for extraction
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');

            let spriteIndex = 1;

            // Sort lines to ensure correct order
            const sortedVerticalLines = [...verticalLines].sort((a, b) => a - b);
            const sortedHorizontalLines = [...horizontalLines].sort((a, b) => a - b);

            // Split sprites based on grid
            for (let row = 0; row < sortedHorizontalLines.length - 1; row++) {
                for (let col = 0; col < sortedVerticalLines.length - 1; col++) {
                    const x = sortedVerticalLines[col];
                    const y = sortedHorizontalLines[row];
                    const width = sortedVerticalLines[col + 1] - x;
                    const height = sortedHorizontalLines[row + 1] - y;

                    if (width <= 0 || height <= 0) continue;

                    tempCanvas.width = width;
                    tempCanvas.height = height;

                    // Draw the sprite
                    tempCtx.clearRect(0, 0, width, height);
                    tempCtx.drawImage(
                        spriteSheetImage,
                        x, y, width, height,
                        0, 0, width, height
                    );

                    // Apply transparency if needed
                    if (removeBackground) {
                        const imageData = tempCtx.getImageData(0, 0, width, height);
                        const data = imageData.data;

                        // Get the color of the top-left pixel as background reference
                        const bgR = data[0];
                        const bgG = data[1];
                        const bgB = data[2];

                        // Make similar colors transparent
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];

                            const diff = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);

                            if (diff < tolerance) {
                                data[i + 3] = 0;
                            }
                        }

                        tempCtx.putImageData(imageData, 0, 0);
                    }

                    // Store sprite
                    sprites.push({
                        canvas: tempCanvas.toDataURL('image/png'),
                        name: `sprite_${spriteIndex.toString().padStart(3, '0')}`,
                        width: width,
                        height: height
                    });

                    spriteIndex++;
                }
            }

            displaySprites();
        }

        function displaySprites() {
            const grid = document.getElementById('spritesGrid');
            grid.innerHTML = '';

            if (sprites.length === 0) return;

            document.getElementById('spriteCount').textContent = sprites.length;
            document.getElementById('spriteSize').textContent = 
                `${Math.round(sprites[0].width)}√ó${Math.round(sprites[0].height)}`;

            sprites.forEach((sprite, index) => {
                const card = document.createElement('div');
                card.className = 'sprite-card';

                const preview = document.createElement('div');
                preview.className = 'sprite-preview';

                const img = document.createElement('img');
                img.src = sprite.canvas;
                preview.appendChild(img);

                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.className = 'sprite-name';
                nameInput.value = sprite.name;
                nameInput.addEventListener('input', (e) => {
                    sprites[index].name = e.target.value;
                });

                const actions = document.createElement('div');
                actions.className = 'sprite-actions';

                const savePng = document.createElement('button');
                savePng.className = 'sprite-btn save-png';
                savePng.textContent = 'PNG';
                savePng.onclick = () => saveSprite(index, 'png');

                const saveJpg = document.createElement('button');
                saveJpg.className = 'sprite-btn save-jpg';
                saveJpg.textContent = 'JPG';
                saveJpg.onclick = () => saveSprite(index, 'jpg');

                actions.appendChild(savePng);
                actions.appendChild(saveJpg);

                card.appendChild(preview);
                card.appendChild(nameInput);
                card.appendChild(actions);

                grid.appendChild(card);
            });

            document.getElementById('spritesSection').style.display = 'block';
        }

        function saveSprite(index, format) {
            const sprite = sprites[index];
            const link = document.createElement('a');
            
            if (format === 'png') {
                link.href = sprite.canvas;
                link.download = `${sprite.name}.png`;
            } else {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = sprite.width;
                canvas.height = sprite.height;
                
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const img = new Image();
                img.onload = () => {
                    ctx.drawImage(img, 0, 0);
                    link.href = canvas.toDataURL('image/jpeg', 0.95);
                    link.download = `${sprite.name}.jpg`;
                    link.click();
                };
                img.src = sprite.canvas;
                return;
            }
            
            link.click();
        }

        function saveAllSprites(format) {
            sprites.forEach((sprite, index) => {
                setTimeout(() => {
                    saveSprite(index, format);
                }, index * 100);
            });
        }

        function resetApp() {
            spriteSheetImage = null;
            sprites = [];
            verticalLines = [];
            horizontalLines = [];
            draggingLine = null;
            editMode = 'grid';
            zoomLevel = 1.0;
            updateZoomDisplay();
            document.getElementById('fileInput').value = '';
            document.getElementById('controls').style.display = 'none';
            document.getElementById('previewSection').style.display = 'none';
            document.getElementById('spritesSection').style.display = 'none';
            document.getElementById('transparentBg').checked = false;
            document.getElementById('toleranceGroup').style.display = 'none';
            document.getElementById('gridModeBtn').classList.add('active');
            document.getElementById('manualModeBtn').classList.remove('active');
            document.getElementById('manualControls').style.display = 'none';
        }
    </script>
</body>
</html>
